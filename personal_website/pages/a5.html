<div class="modal-header border-0">
    <button
      class="btn-close"
      type="button"
      data-bs-dismiss="modal"
      aria-label="Close"
    ></button>
  </div>
  <div class="modal-body text-center pb-5">
    <div class="container">
      <div class="row justify-content-center">
        <div class="col-lg-11">
          <!-- Portfolio Modal - Title-->
          <h2 class="portfolio-modal-title text-secondary text-uppercase mb-0">
            Assignment 5
          </h2>
          <!-- Icon Divider-->
          <div class="divider-custom">
            <div class="divider-custom-line"></div>
          </div>
          <!-- Portfolio Modal - Image-->
          <!-- Portfolio Modal - Text-->
          <!-- Accordion -->
          <div class="accordion-body">
            <!-- Accordion item 1 -->
            <button
              class="accordion-button collapsed mb-3"
              data-bs-toggle="collapse"
              data-bs-target="#assignment-q1"
              aria-expanded="false"
            >
              1. Lambda Function to CRUD over the Students DynamoDB table.
            </button>
            <div id="assignment-q1" class="collapse mb-3">
              <div align="justify">
                <p>
                  Before starting to create a Lambda Function, let's remember what it is.
                </p>
                <p>
                  AWS Lambda is a compute service that lets you run code without provisioning or managing servers. Lambda runs your code on a compute infrastructure and performs all of the administration of the compute resources, including server and operating system maintenance, capacity provisioning and automatic scaling, and logging. 
                With Lambda, you can run code for virtually any type of application or backend service. To see a list of the languages that Lambda supports, visit <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">Lambda runtimes</a>. <br>
                In other words, we can say that a Lambda function is a serverless service, or FaaS (Function as a Service), that allows us to run code within other AWS Services. One of the main advantages of Lambda, is that it allows the developer on focusing more on the code, letting the service to run the managing tasks.
                </p>
                <p>
                  There are advantages when using AWS Lambda, one of the main advantages is the <b>scalability</b> of applications and projects. Let's have a look at some advantages:
                </p>
                <p>
                  <b>Advantages:</b>
                  <ul>
                    <li><b>Scalability: </b>It's a highly scalable service. Helps to handle large volume of requests</li>
                    <li><b>Cost-effective:c</b>Depending of the number of requests and time of execution of the code, so only pay for what it is used</li>
                    <li><b>Low maintenance:c</b>The developer doesn't have to worry about management, operating systems or patching. AWS does all maintenance.</li>
                    <li><b>Integration with other AWS services: </b>It easily integrates with other services such as Amazon S3, Amazon DynamoDB, and Amazon API Gateway</li>
                  </ul>
                </p>
                <p>
                  There are also some disadvantages that we can come across when using Lambda functions.
                </p>
                <p>
                  <b>Disadvantages:</b>
                  <ul>
                    <li><b>Cold start delays:</b> It takes longer to start up at the first time the function is executed, causing delays</li>
                    <li><b>Limited execution time:</b> It has a maximum execution time of 15 minutes, so this may not be enough for certain cases</li>
                    <li><b>Limited resources:</b> It hast a limited amout of CPU, memory and network resources available. So it not my be enough for some applications</li>
                    <li><b>Debugging can be challenging:</b> In contrast with traditional debugging, AWS Lambda requires to work remotely, as the code runs in the cloud, and you will rely on debugging and monitoring tools to do it. This may not reproduce the same conditions that caused the problem, also, it can be difficult to trace the flow of events 
                    thorugh the system and determine where the problem is ocurring</li>
                  </ul>
                </p>
                <p>
                  To create a Lambda Function, we simply use the AWS CLI with the corresponding command, and specify the settings for the Lambda Function. But this is tricky becuase there are some things that need to be considered. <br>
                  In this case, we are going to create a Lambda function to run Python code. To do this, we need to create something called <code>a deployment package</code>, this is neccesary to deploy code to Lambda. A deployment package will act as the source bundle to run our function's code and its dependencies. <br>
                  Lambda supports two types of deployment packages: container images and zip files. We are using <b>zip files</b> for our Lambda. <br>
                  In this zip file, we need to <b>include the application code and its dependencies (if any).</b>
                </p>
                <p>
                  Let's go back to our python scripts that did stuff into DynamoDB. These scripts were used to <code>create</code>, <code>update</code>, <code>find</code> or <code>delete</code> an item on a table. Now we want to create a AWS Lambda function that CRUD over this. <br>
                  <b>NOTE:</b> CRUD stands to <b>CREATE</b>, <code>READ</code>, <code>UPDATE</code> and <code>DELETE</code>, in relationship with HTTP requests, they refer to the HTTP methods: POST, GET, PATCH and DELETE. In this example we are using PATCH over PUT. <br>
                  So we are perfoming the same operations, but these time, the Lambda function will perform these operations.
                </p>
                <p>
                  <ol>
                    <li>
                      First, we need to integrate our 4 scripts into a single script, or file. So we can just call the file and choose what to do. I have integrated my scrtips into one file and define every actions as a <code>function</code>. Additionally, I modified a little bit every function, this is it looks like:
                      <img src="assets/img/assignment_imgs/assignment5/q1_crudScript.png" width="100%" alt="">
                      The payload in every function is the information what will be passed in to the function to do the corresponding action. This information can have several ways, in this case, the payload will be passed in as a API request.
                    </li>
                    <li>
                      After having our script integrated, we need to create another file. This file will be a function that will handle our Lambda every time we run it. It is called <b>the handler</b>. <br>
                      The handler is the name of the method within our code that Lambda calls to run our function and process events. When a Lambda function is invoked, it runs the handler method. When the handler method is invoked, the Lambda passes two arguments: <code>event</code> and <code> context.</code> <br>
                      <b>Event</b> is an object that contains information from the invoking service. In other words, the event is from where, or what, the Lambda will get the information from to perform some action. <br>
                      <b>Context</b> is an object that provides methods and properties that provide information about the invocation, function and runtime environment. In other words, we can see the context object as the meta data of our runtime environment.
                      <br>
                      Since we are using a ZIP file as our deployment package, this <b>handler is required.</b> <br>
                      Let's create our Lambda handler function in another file. We are going to call this file <code>lamda_function.py</code>
                      <img src="assets/img/assignment_imgs/assignment5/lambda_handler.png" width="100%" alt="">
                      In this case, we are going to get the information to perfom a CRUD action from an event, and this event could be either a JSON file that is passed in, or an API call. Note that I'm importing my Python script called <code>crud_dynamobd</code> wich do the CRUD actions. So I need to place these 2 files (lambda_function.py and crud_dynamodb.py) inside the same folder so these files 
                      will be my deployment package.
                    </li>
                    <li>
                      Now that I have my 2 files that will be my deployment package, simply create a ZIP file containing these files. <b>REMEMBER</b> to include all your code dependencies to the ZIP file as well.
                    </li>
                    <li>
                      Now we proceed to create our Lambda Function, we can use the following command on the AWS CLI: <br>
                      <code>aws lambda create-function --function-name jaxelc-lambda --runtime python3.9 --zip-file fileb://lambda_funcion.zip --handler lambda_function.lambda_handler --role LAMBDA_ARN_ROLE</code> <br>
                      <ul>
                        <li><b>--function-name</b> The name of the function. It could be any string. In this case my Lambda function will be named jaxelc-lambda </li>
                        <li><b>--runtime</b> This is the environment on which you want your Lambda to rune your code. In this case I'm using Python version 3.9</li>
                        <li><b>--zip-file</b> This is de deployment package. Remember to include any code files and dependencies (if any) to your ZIP file</li>
                        <li><b>--handler</b> The handler is a file with the function that will be invoked by the Lambda to run any operation. And the method that it is inside this file that will get the information or data to perform certain operations.</li>
                        <li><b>--role</b> This is a AWS ARN role that has permissions to perform actions over Lambda.</li>
                      </ul>
                      You can look for you ARN role using the command: <br>
                      <code>aws iam list-roles</code> <br>
                      Just look for the arn that has permission over Lambda.
                    </li>
                    <li>
                      After creating a Lambda we will get an output like this:
                      <img src="assets/img/assignment_imgs/assignment5/lambda_creation_output.png" width="100%" alt="">
                      Also we can check if our Lambda is ready to go, with the following command: <br>
                      <code>aws lambda get-configuration --function-name jaxelc-lambda</code> <br>
                      And we will get a similar output.
                      <img src="assets/img/assignment_imgs/assignment5/lambda_function_config.png" width="100%" alt="">
                    </li>
                    <li>
                      We can test if our Lambda if working properly by using the <code>lambda invoke</code> command. And passing in data from a JSON file. There are several way to pass in data as the payload for the Lambda, in this case I will use a JSON file with the data for the Lambda. <br>
                      The invoke command: <br>
                      <code>aws lambda invoke --function-name jaxelc-lambda --cli-binary-format raw-in-base64-out --payload file://payload.json response.json</code> <br>
                      The JSON file that works as payload for the Lambda looks like this:
                      <img src="assets/img/assignment_imgs/assignment5/invoke_json_file.png" width="100%" alt="">
                      Here I'm specifying data to be pass in as a <code>--payload</code> for the Lambda. <br>
                      Let's use the invoke command, and if it runs successfully we will get corresponding output
                      <img src="assets/img/assignment_imgs/assignment5/lambda_invoke_test.png" width="100%" alt="">
                      Here I'm specifying to get the response as a JSON file. Let's see is the response of our Lambda:
                      <img src="assets/img/assignment_imgs/assignment5/invoke_response_json.png" width="100%" alt="">
                      As we can see, the Lambda is working correctly because the response is returning a <code>statusCode 200</code>.
                    </li>
                  </ol>
                </p>
                <p>
                  Now our Lambda function is created and works correctly, we can test other operations from our handler by just passing the data as a <code>--payload</code> and check the response for every operation we want to test.
                </p>
              </div>
            </div>
  
            <!-- Accordion item 2 -->
            <button
              class="accordion-button collapsed mb-3"
              data-bs-toggle="collapse"
              data-bs-target="#assignment-q2"
              aria-expanded="false"
            >
              2. API Gateway API to CRUD over Lambda function.
            </button>
            <div id="assignment-q2" class="collapse mb-3">
              <div align="justify">
                <p>
                  <b>What is API Gateway?</b><br>
                  It is a fully-managed service that makes it easy to create, publish, maintain, monitor, and secure APIs. It serves as a front door for the application, by allowing us to connect backend services to the internet or other client applications in a secure way.
                </p>
                <p>
                  API Gateway can help us to create a RESTful API and integreate AWS services with other HTTP endpoints, can be with other APIs as well. Also, we can transform and route requests, apply security policies, and monitor the API usage and performance.
                </p>
                <p>
                  To create a RESTful API with AWS API Gateway, we can run the following command on the AWS CLI: <br>
                  <code>aws apigateway create-rest-api --name jaxelc-rest-api</code> <br>
                  Output:
                  <img src="assets/img/assignment_imgs/assignment5/api_create_api.png" width="100%" alt="">
                  Here we get the main details of our API.
                </p>
                <p>
                  Now we need to add the resources that operates in the APIs. These resources are objects that clients interact with. These resources are used to define the paths and operations that clients can invoke. <br>
                  So in order for the users to use our API, we need to add these resources.
                </p>
                <p>
                  Let's start by checking whether if our API has any resource. We use the following command: <br>
                  <code>aws apigateway get-resources --rest-api-id i3jytdsbre</code>
                  <img src="assets/img/assignment_imgs/assignment5/api_get_resources_1.png" width="100%" alt="">
                  As we can see there no resource yet in our API, however, there is an ID in there, this is the parent ID of our API and the parent PATH, this is necessary to add the resources to the API. 
                </p>
                <p>
                  Let's create the resources that the API will have. To work well with our scripts, we are going to use resources to:
                  <ul>
                    <li>A resource to show the items on the Students Dynamodb table</li>
                    <li>A resource to show the created item after its creation</li>
                    <li>A resource to show an item after finding it by its id</li>
                    <li>A resource to show an item after updating it</li>
                    <li>A resource to show the id of a deleted item</li>
                  </ul>
                  To create the resources we use the command: <br>
                  <code>aws apigateway create-resource --rest-api-id API_ID --parent-id PARENTH_PATH_ID --path-part RESOURCE_NAME</code> <br>
                  Here, the <code>--rest-api-id</code> is the id of the api just created. The <code>--paren-id</code>, means the id of the path where you want your resource to be, and the <code>--path-part</code> is the resource name.
                </p>
                <p>
                  Every resource is created within the parent path of the API, meaning the root path. So for example, the path for the resource to show the students in the dynamodb table will be like <code>/students</code>, the resource to see the details of a 
                created item would be <code>/created</code>, and so on. <br>
                The only resource that will not be in the root path, will be the one to show the id of an item after it is deleted. So we need to create a resource path for the deleted item, and then create a resource path for the id. So with the command: <br>
                <code>aws apigateway create-resource</code> instead of the parent-id of the root, we are going to set the <code>deleted</code> resource id as the parent id. With this, the resource will have the path of <code>/deleted/{id}</code>
                <img src="assets/img/assignment_imgs/assignment5/create_resource_deleted_id.png" width="100%" alt="">
                </p>
                <p>
                  Now what we need to do is to add the <code>HTTP Methods</code> that we want to use in the API. In this case we are going to use <code>POST</code> for creating, <code>GET</code> for reading, <code>PATCH</code> for updating and <code>DELETE</code> for deleting. <br>
                  Before adding the HTTP methods, we need to go back to our <code>lambda_handler</code> method in our Lambda function file and change the keyword to represent the HTTP methods.
                  <img src="assets/img/assignment_imgs/assignment5/lambda_http_methods.png" width="100%" alt="">
                  This will help us to tell the relate the HTTP methods added to the API to be invoked with the Lambda function. <br>
                  After modifying the code, we need to update the deployment package of the Lambda function, because we updated the code. Just create a new ZIP file of the new modified code, the same files with the new changes will be included in the ZIP file. <br>
                  Having the ZIP file, just use the command to update the configuration code of the Lambda: <br>
                  <code>aws lambda update-function-code --function-name jaxelc-lambda --zip-file fileb://lambda_function.zip</code>
                  Just wait a couple of seconds for the changes to take place.
                </p>
                <p>
                  Now we have to put the HTTP methods that we are going to use with our API. Remeber that we are going to use <code>POST</code>, <code>GET</code>, <code>PATCH</code> and <code>DELETE</code>. <br>
                  To add a method we use the following command: <br>
                  <code>aws apigateway put-method  --rest-api-id API_ID --resource-id RESOURCE_ID --http-method GET --authorization-type "NONE" --region us-east-1</code> <br>
                  In this case just need to replace <b>API_ID</b> with your API id, and the <b>RESOURCE_ID</b> with the resource id you want to add this method.
                </p>
                <p>
                  We run the command above for every method we want to use and on which resource we want the API to do it. <br>
                  For example, I want to add the <code>POST</code> HTTP method for my API resource that I created that shows the item after creating it. The command looks like this: <br>
                  <code>aws apigateway put-method --rest-api-id i3jytdsbre --resource-id 472k48 --http-method POST --authorization-type "NONE" --region us-east-1</code> <br>
                  Just use this command for every resource that will use an HTTP method, changing the id of the resource and the corresponding HTTP method for each resource.
                </p>
                <p>
                  Putting all methods for the resources: <br>
                  <ul>
                    <li>
                      The method for the resource on showing all items - resource path: /students<br>
                      <code>aws apigateway put-method --rest-api-id i3jytdsbre --resource-id dyvvma --http-method GET --authorization-type "NONE" --region us-east-1</code>
                    </li>
                    <li>
                      The method for the resource on creating an item - resource path: /students/created<br>
                      <code>aws apigateway put-method --rest-api-id i3jytdsbre --resource-id 472k48 --http-method POST --authorization-type "NONE" --region us-east-1</code>
                    </li>
                    <li>
                      The method for the resource on finding an item - resource path: /students/{id} <br>
                      <code>aws apigateway put-method --rest-api-id i3jytdsbre --resource-id 6hkxn7 --http-method GET --authorization-type "NONE" --request-parameters method.request.path.id=true --region us-east-1</code>
                    </li>
                    <li>
                      The method for the resource on updating an item - resource path: /students/updated/{id} <br>
                      <code>aws apigateway put-method --rest-api-id i3jytdsbre --resource-id pcan0l --http-method PATCH --authorization-type "NONE" --request-parameters method.request.path.id=true --region us-east-1</code>
                    </li>
                    <li>
                      The method for the resource on deleting an item - resource path: /students/deleted <br>
                      <code>aws apigateway put-method --rest-api-id i3jytdsbre --resource-id t34vfi --http-method DELETE --authorization-type "NONE" --region us-east-1</code>
                    </li>
                  </ul>
                  Note that, in the resources where we have the id resource, we need to specify the path parameters <code>method.request.path.id=true</code> for the resource, because this id is dynamic, so it changes depending on the item. The <code>id</code> word after the path is the name of the resource, in this case <b>{id}</b> <br>
                  Also we set the <code>--authorization-type</code> to <b>"NONE"</b> because we don't need an authorization key or token at this moment to access the methods.
                </p>
                <p>
                  Now that we have put every necessary method to our API resources, the following step is to integrate them. Since we are going to use our Lambda function, and our API will do the operations over the Lambda function, we are going to integrate the methods using a <b>PROXY</b> for the Lambda. <br>
                  There are many ways to integrate the methods, in this case a <b>API Gateway Lambda proxy integration</b> is a simple and powerful way to do it, because it allows us to call our Lambda function in the backend, also when we submit an API request, the API passes to the Lambda function the <b>raw request</b> including: <code>headers, query string parameters, URL path variables, payload</code> and <code>API configuration data</code>. <br>
                  Knowing this, we are going to set up a Lambda proxy integration for our API methods. So we put the integration using the proxy like this: <br>
                  <code>aws apigateway put-integration --region us-east-1 --rest-api-id i3jytdsbre --resource-id 6hkxn7 --http-method GET --type AWS_PROXY --integration-http-method POST --uri arn:aws:apigateway:us-east-1:lambda:path/2015-03-31/functions/arn:aws:lambda:us-east-1:292274580527:function:jaxelc-lambda/invocations</code> <br>
                  This will integrate out method <code>GET</code> for our resource with id <code>6hkxn7</code> that our API uses to return an item after finding it. <br>
                  There are several things with this method:
                  <ul>
                    <li><b>--rest-api-id:</b> The id of API Gateway API</li>
                    <li><b>--resource-id:</b> The id of the resource with are integrating with the method</li>
                    <li><b>--http-method:</b> The method we are integrating with the resource</li>
                    <li><b>--type:</b> The type of integration, as mentioned, we are using a Lambda Proxy integration. There are other several types of integrations: HTTP, MOCK, HTTP_PROXY. In this case we are using <code>AWS_PROXY</code></li>
                    <li><b>--integration-http-method:</b> This is the method of the integration for the Lambda. Lambdas use POST method as integration methods.</li>
                    <li><b>--uri:</b> This specifies the Uniform Resource Identifier, which is the integration endpoint. In this case, we are telling to integrate the uri of the Lambda function to the API.</li>
                  </ul> 
                </p>
                <p>
                  Now we just need to integrate the rest of our methods. The command above integrates the <code>GET</code> method, so we need to integrate the <code>POST</code>, <code>PATCH</code> and the <code>DELETE</code> methods. <br>
                  <ul>
                    <li>
                      Integrating the <b>POST</b> method: <br>
                      <code>aws apigateway put-integration --region us-east-1 --rest-api-id i3jytdsbre --resource-id 472k48 --http-method POST --type AWS_PROXY --integration-http-method POST --uri arn:aws:apigateway:us-east-1:lambda:path/2015-03-31/functions/arn:aws:lambda:us-east-1:292274580527:function:jaxelc-lambda/invocations</code>
                    </li>
                    <li>
                      Integrating the <b>PATCH</b> method: <br>
                      <code>aws apigateway put-integration --region us-east-1 --rest-api-id i3jytdsbre --resource-id pcan0l --http-method PATCH --type AWS_PROXY --integration-http-method POST --uri arn:aws:apigateway:us-east-1:lambda:path/2015-03-31/functions/arn:aws:lambda:us-east-1:292274580527:function:jaxelc-lambda/invocations</code>
                    </li>
                    <li>
                      Integrating the <b>DELETE</b> method: <br>
                      <code>aws apigateway put-integration --region us-east-1 --rest-api-id i3jytdsbre --resource-id t34vfi --http-method DELETE --type AWS_PROXY --integration-http-method POST --uri arn:aws:apigateway:us-east-1:lambda:path/2015-03-31/functions/arn:aws:lambda:us-east-1:292274580527:function:jaxelc-lambda/invocations</code>
                    </li>
                  </ul>
                  If the command runs successfully, the output should look like this: <br>
                  <img src="assets/img/assignment_imgs/assignment5/api_put_integration_GET.png" width="100%" alt="">
                </p>
                <p>
                  Now we have to give permissions to our Lambda to let access of our API. This is done with the <code>add-permission</code> command from Lambda. So we are going to tell our Lambda function to allow access of our API: <br>
                  <code>aws lambda add-permission --function-name jaxelc-lambda --action lambda:InvokeFunction --statement-id apigateway-jaxelc-lambda --principal apigateway.amazonaws.com</code> <br>
                  Here we have:
                  <ul>
                    <li><b>--function-name:</b> The name of the Lambda that we are giving permission</li>
                    <li><b>--action:</b> The method, or action, of what the Lambda will do, in this case, the API will invoke the Lambda function</li>
                    <li><b>--statement-id:</b> The id of this permision. This is an unique identifier. It can be any string</li>
                    <li><b>--principal:</b> The service to which the Lambda will give permission. In this case API Gateway</li>
                  </ul>
                  This command outputs with the Lambda permission details
                  <img src="assets/img/assignment_imgs/assignment5/lambda_permission_api.png" width="100%" alt="">
                </p>
                <p>
                  Finally, we need to deploy our API Gateway APi. We use the following command to create a deployment for our API: <br>
                  <code>aws apigateway create-deployment --rest-api-id i3jytdsbre --stage-name prod --description 'Production stage deployment'</code>
                  This will deploy our API. This is the output of the deployment creation:
                  <img src="assets/img/assignment_imgs/assignment5/api_deployment_created.png" width="100%" alt="">
                </p>
                <p>
                  Now just need to go to the API URL and test it. In this case I'm going to use <b>Postman</b> to test the API. <br>
                  The URL for testing the API looks like this: <br>
                  <code>https://{api_id}.execute-api.{region}.amazonaws.com/{stage_name}/{resource_name}</code> <br>
                  <ul>
                    <li><b>api_id</b> The id of the API, in this case my API id is <code>i3jytdsbre</code></li>
                    <li><b>region</b> The region, in this is <code>us-east-1</code></li>
                    <li><b>stage_name</b> The name of the stage when created the deployment. In this case my stage is called <code>prod</code></li>
                    <li><b>resource_name</b> The name of the resource you want to test. In this case I'm going to test the resource that finds an item base on the id. So it would be <code>students/31973</code> so the form of the resource is 'students/{id}'</li>
                  </ul>
                  So the URL to test this would be: <br>
                  <code>https://i3jytdsbre.execute-api.us-east-1.amazonaws.com/prod/students/31973</code>
                </p>
                <p>
                  Before going into Postman and test out API, we need to go back one more time to our Lambda function file, and change the way we are getting the <b>HTTP method</b>. This step is important because, accordingly to the AWS Lambda Proxy Integrations Documentation, there is an input format of a Lambda function proxy integration. We 
                  can check the complete input format by visiting <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html#api-gateway-simple-proxy-for-lambda-input-format">Input format of a Lambda function for proxy integration.</a> <br>
                  With this, we change our Lambda hanlder to get the corresponding HTTP method when sending a request using the API Gateway API we created. So the new <code>lambda function file</code> will look like this:
                  <img src="assets/img/assignment_imgs/assignment5/lambda_handler_updated.png" width="100%" alt="">
                </p>
                <p>
                  Also, I have to modify the <b>CRUD functions</b> to be according with the input format for the lambda proxy. This will allow our functions handle the input data correctly according to this input format.
                  <ul>
                    <li><b>Update on the create function:</b></li>
                    <img src="assets/img/assignment_imgs/assignment5/create_function_updated.png" width="100%" alt="">
                    <li><b>Update on the read function:</b></li>
                    <img src="assets/img/assignment_imgs/assignment5/get_function_updated.png" width="100%" alt="">
                    <li><b>Update on the update function:</b></li>
                    <img src="assets/img/assignment_imgs/assignment5/update_function_updated.png" width="100%" alt="">
                    <li><b>Update on the delete function:</b></li>
                    <img src="assets/img/assignment_imgs/assignment5/delete_function_updated.png" width="100%" alt="">
                  </ul> 
                  These updated functions will handle better our API requests when sending the data on the request.
                </p>
                <p>
                  Now we can go a test our API =D. Here is the example of testing the <code>GET</code> method using our api testing URL:
                  <img src="assets/img/assignment_imgs/assignment5/postman_api_test_GET.png" width="100%" alt="">
                </p>
                <p>
                  It looks like the API is working properly. =)
                </p>
              </div>
            </div>
  
            <!-- Accordion item 3 -->
            <button
              class="accordion-button collapsed mb-3"
              data-bs-toggle="collapse"
              data-bs-target="#assignment-q3"
              aria-expanded="false"
            >
              3. Implementation of 404 HTTP response when invalid id is passed to read in the API Gateway/Lambda.
            </button>
            <div id="assignment-q3" class="collapse mb-3">
              <div align="justify">
                <p>
                  As this was done in the first question, meaning that I created the Lambda with the error handling inside my functions. And we can test if the error handling works by sending a request to API and see if it returns an <code>404 Error</code>. Let's test it with a <code>GET</code> request of a <b>id that does not exists.</b>
                  <img src="assets/img/assignment_imgs/assignment5/postman_api_test_GET_error.png" width="100%" alt="">
                  As we can see, if we look for an item with a <b>non-existing id</b> we get a <code>statusCode: 404</code>, meaning that an Item with this id is not present in the DynamoDB table.
                </p>
                <p>
                  We can also test by trying to <code>DELETE</code> an item with a non-existing id. Let's try
                  <img src="assets/img/assignment_imgs/assignment5/postman_api_test_DELETE_error.png" width="100%" alt="">
                </p>
                <p>
                  Here are my functions where I handle these errors
                  <ul>
                    <li><code>GET</code><br>
                      <img src="assets/img/assignment_imgs/assignment5/get_function_updated.png" width="100%" alt="">
                    </li>
                    <li><code>PATCH</code><br>
                      <img src="assets/img/assignment_imgs/assignment5/update_function_updated.png" width="100%" alt="">
                    </li>
                    <li><code>DELETE</code><br>
                      <img src="assets/img/assignment_imgs/assignment5/delete_function_updated.png" width="100%" alt="">
                    </li>
                  </ul>
                  
                  
                </p>
              </div>
            </div>

            <!-- Accordion item 4 -->
            <button
              class="accordion-button collapsed mb-3"
              data-bs-toggle="collapse"
              data-bs-target="#assignment-q4"
              aria-expanded="false"
            >
              4. Test Driven Developement is the best thing that has happened to software design.
            </button>
            <div id="assignment-q4" class="collapse mb-3">
              <div align="justify">
                <p>
                  TDD (Test Driven Developement) is based on the the idea of a <em>'fail-pass-refactor'</em>. This means that when writing software using this technique TDD, there is no need to know how the final product will look like, this involves knowing the code structure such as class names, methods, or implementation details.
                </p>
                <p>
                  TDD is know to be an iterative approach that helps software to become an 'elegant' solution. This means that the software works as expected in certain way that is well interpreted by every environment. It is a fancy approach!.
                </p>
                <p>
                  There are things to consider, and this approach supports every one of them. Let's think about creating an application, we can write code and then test it, or backwards, we can write some tests cases and the write the code. This may seem farfecthed, but thanks to TDD, these 2 design solutions are a good to go approach.
                </p>
                <p>
                  <ol>
                    <li>When writing code first and then you need to test it. You write some tests and find out that your code runs perfectly and passes all the tests. This may sound perfect, but there are still some downs because details about implementation. Then some questions arise that can break this approach down: <em>When to testing? How to know coding is done?</em></li>
                    <li>On the other hand, when start by defining some tests first, there are some benefits. First the tests can verify behaviours and not implementation details. Secondly, the documentation is always up to date, and the code is written based on this documentation. And the only actual question that rises from this approach is: <em>what to expect from the code?</em></li>
                  </ol>
                </p>
                <p>
                  In some cases, you can be in the situation where you have code that it may seem impossible to test, and TDD helps to know how to use it on this kind of code. There are some ways: <br>
                  <ul>
                    <li>
                      <b>Spying and Mocking</b><br><em>There is no way to write a proper test!</em> This can happen when writing code first and tests are postponed. If test are postponed that much, it becomes so difficult to write tests for existing code, as code grows, so the complexity of it.
                    </li>
                    <li>
                      <b>Variable Test Data</b><br>
                      Not all data is indempotent, so we writing tests and test some code, not always will get the same results. Also, there might be data that it is outside the block or scope being tested, so it will be difficult to know if the problem comes from outside the code or from another method.
                    </li>
                    <li>
                      <b>Bloated Setup</b><br>
                      When having methods that need to be initialized from other methods or services, there might rise some delays in the startud of these methods, and the object might either has too many dependencies or the Single Responsibility principle has been broken.
                    </li>
                    <li>
                      <b>Mocking Hell</b><br>
                      Nobody wants to stuck in going back to see mocks that return another muck and so on and so on. This hell is due to breaking the <em>The Law of Demeter</em> which implies that information is leaking from one component to another. Now you can think, is the production code ok or the tests? Because of a small change can lead to a butterfly effect into these.
                    </li>
                  </ul>
                </p>
                <p>
                  It's imporant to know, or think, that TDD being the 'best thing' that has happened to software design is subjective and dependes on a lot of factors, including the actual project and the development team. Yes, TDD is found to be very useful by some developers and organizations to catch bugs and errors early in development processes, and this can result in better code quality, 
                  However, there are different development technologies and practices out there that can work better for different teams or projects, and what works best for some organization might not work as well as that for another.
                </p>
              </div>
            </div>

          </div> <!-- ends accordion -->

          <button class="btn btn-primary" data-bs-dismiss="modal">
            <i class="fas fa-xmark fa-fw"></i>
            Close Window
          </button>
        </div>
      </div>
    </div>
  </div>
  